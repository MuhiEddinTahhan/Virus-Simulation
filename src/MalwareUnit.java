/**
 * Name: Muhi Eddin Tahhan
 * Date: January 25th, 2024
 * Description: Simulation of Malware and how it functions
 */

import Skeleton.*;
import java.util.*;

/**
 * MalwareUnit class that extends the Unit class for malware simulation.
 * This class simulates malicious activities such as sending emails,
 * establishing connections, dumping SAM files, and cracking passwords.
 * All actions are simulated with print statements for educational purposes.
 */
public class MalwareUnit extends Unit implements MalwareActionSubject{

    private final Action nextAction;
    private static List<String> IPAddresses;                                    // The IP addresses list
    private static final Map<String, String> password = new HashMap<>();        // The passwords list corresponding to their IPs
    private final List<MalwareUnitTemplate> viruses;                           // List to hold all virus instances
    private DatabaseDisplayStrategy displayStrategy;                            // interface to display the database
    private static final Object lock = new Object();                            //lock to keep the generated IP addresses the same in all the instances. "only used when generating IPs"
    private final List<MalwareActionObserver> observers = new ArrayList<>();    //list of observers objects

    /**
     * this method adds an observer to the List of observers
     * @param observer the observer object
     */
    @Override
    public void addObserver(MalwareActionObserver observer) {
        observers.add(observer);
    }

    /**
     * this method removes an observer to the List of observers
     * @param observer the observer object
     */
    @Override
    public void removeObserver(MalwareActionObserver observer) {
        observers.remove(observer);
    }

    /**
     * This method is used to notify the observer with the action that is being done "serves as an extra logging system to the actions of the class"
     * @param action the action that is going to be done by the virus.
     */
    @Override
    public void notifyObservers(String action) {
        for (MalwareActionObserver observer : observers) {
            observer.update(this, action);
        }
    }

    /**
     * enum to Identify actions, making it easier to control the flow of the program
     */
    public enum Action {
        SCAN, SEND_EMAIL, ESTABLISH_CONNECTION, DUMP_SAM_FILE, CRACK_PASSWORD, DELETE_LOGS
    }

    /**
     * Constructs a new MalwareUnit with a specified name and simulation input.
     * @param name  The name of the malware unit.
     * @param input The simulation input parameters.
     * @param nextAction the action that the virus will do.
     * @param strategy the interface object that is being implemented.
     */
    public MalwareUnit(String name, SimulationInput input, Action nextAction, DatabaseDisplayStrategy strategy) {
        super(name, input);
        this.nextAction = nextAction;
        this.viruses = new ArrayList<>();
        this.displayStrategy = strategy;
        IPAddresses = input.getInput("TargetIPs");            // initialize the Target IPs
        initializeSharedResources(input);                          // Initialize when there is no list of IPs were given
        Statistic activeUnit = getStats().getStatistic("ActiveUnits");  //initialize the active units statistics
        IPAddresses.forEach(ip -> {                               //for each IP, create a password
            if (password.get(ip) == null) {                        //as long as this IP doesn't have a password
                setPassword();                                    //Use the function to add the passwords to the IP
            }
        });
        IPAddresses.forEach(ip -> {                             //for every IP in the list of IP addresses
            MalwareUnitTemplate virus = createVirus(ip);        //create a virus
            viruses.add(virus);                                 //for every new virus that is created, add 1 to the statistics of active units
            activeUnit.addValue(1);
        });
        this.getStats().addStatistic("MalwareActionsPerformed", new WorkerStatistic("MalwareActionsPerformed"));    //initialize the actions preformed statistics
    }

    /**
     * the method is responsible for initializing new IPs if there is time in the simulation and no list of IPs were given
     *
     * @param input the input that is passed to by the SimulationInput class
     */
    private static void initializeSharedResources(SimulationInput input) {
        if (IPAddresses == null || IPAddresses.isEmpty()) {                     //if the IP addresses list is empty
            synchronized (lock) {                                                //start an object that is synchronized across other viruses
                try {
                    List<String> ips = input.getInput("TargetIPs");            //initialize ips list
                    if (ips == null || ips.isEmpty()) {                             //if its empty
                        new IPAddressGenerator(input);
                        IPAddresses = IPAddressGenerator.getInstance().generateRandomIPAddresses();        //generate new IPs based on how much time is given in the input
                        System.out.println("Generated IP Addresses as none were provided.");
                    } else {
                        IPAddresses = ips;                                                             //otherwise, use the IPs that were generated
                    }
                } catch (RuntimeException e) {
                    IPAddresses = new IPAddressGenerator(input).generateRandomIPAddresses();
                    System.out.println("Handled exception, generated IP Addresses: " + e.getMessage());
                }
            }
        }
    }

    /**
     * the createVirus class is based on the MalwareUnitTemplate. it returns what the virus should do based on the action that was passed
     * @param ip the IP that is being processed
     * @return the action that the virus should do
     */
    private MalwareUnitTemplate createVirus(String ip){
        return switch (nextAction) {                                            //based on the action
            case SCAN -> new Scan(ip);                                          //start a scan object
            case SEND_EMAIL -> new SendingEmail(ip);                            //start a sending email object
            case ESTABLISH_CONNECTION -> new EstablishConnection(ip);           //start an establish connection object
            case DUMP_SAM_FILE -> new DumpSAMFile();                            //start a dump sam file object
            case CRACK_PASSWORD -> new CrackPassword(ip, password.get(ip));     //start a cracking password object
            case DELETE_LOGS -> new DeleteLogs(ip);                             //start a delete logs object
        };
    }

    /**
     * the function is used to set the IP addresses list
     * @return the IPAddress list
     */
    public static List<String> setIPAddress(){
        return MalwareUnit.IPAddresses;
    }

    /**
     * Default constructor for MalwareUnit.
     * Uses a default name and given simulation input.
     * @param input The simulation input parameters.
     */
    public MalwareUnit(SimulationInput input, Action nextAction, DatabaseDisplayStrategy strategy) {
        this("DefaultMalwareUnit", input, nextAction, strategy);
    }

    /**
     * setter method for the DisplayStrategy method
     * @param strategy is the DatabaseDisplayStrategy interface
     */
    public void setDisplayStrategy(DatabaseDisplayStrategy strategy) {
        this.displayStrategy = strategy;
    }

    /**
     * show the database of the IP addresses with their corresponding passwords
     */
    public void displayDatabase() {
        if (displayStrategy != null) {                          //while display strategy is not empty
            displayStrategy.display(IPAddresses, password);     //show the IPs with their passwords
        } else {
            System.out.println("Display strategy not initialized.");
        }
    }

    /**
     * Submit the number of actions performed (always 1).
     * Use submitStatistics for things you want to submit AFTER the action is complete
     * (this could be for things involving combination metrics, or conditional metrics).
     */
    public void submitStatistics() {
        Statistic stat = this.getStats().getStatistic("MalwareActionsPerformed");  // Correct the name here too
        if (stat != null) {
            stat.addValue(1);
        } else {
            System.err.println("Statistic 'MalwareActionsPerformed' not found.");
        }
    }

    /**
     * Simulates the actions of the malware.
     * Each action is run in a separate thread with a delay between them.
     */
    @Override
    public void performAction() {
        int timeToRun = 0;                                               //initialize at 0 "this variable is used to handle the 0 times exception"
        try {
            timeToRun = getSimInput().getIntegerInput("Time");      //set the variable to equal how many times is the program is set to preform its actions
        } catch (NumberFormatException e) {
            System.err.println("Invalid format for Time input, defaulting to 0");
        }
       if (timeToRun > 0){                                               //any other case aside from 0
           notifyObservers("Starting all actions for " + getName());  // Notify before actions start
           viruses.forEach(MalwareUnitTemplate::attackHost);                //preform the attack
           notifyObservers("All actions completed for " + getName());  // Notify after all actions are done
       } else {
           System.out.println("The \"Time\" input was 0 or not added");
       }
    }

    /**
     * Generate a random password for the IPs in the IPAddress list "helps with the simulation of cracking a password"
     */
    private static void setPassword() {
        IPAddresses.forEach(ip ->{                                                                   //for each IP in IPAddress list
            String passwordValue = UUID.randomUUID().toString().replace("-","");    //generate a random string based on the UUID
            password.put(ip, passwordValue);                                                         //assign the password to the IP
        });
    }

    /**
     * the scan class is used to simulate a scan for IP addresses.
     */
    static class Scan extends MalwareUnitTemplate{
        private final String ip;                //ip address

        /**
         * scan constructor that takes ip as parameter
         * @param ip the IP that is being scanned
         */
        public Scan(String ip) {
            this.ip = ip;
        }

        /**
         * this function checks if the IPAddress is null, if so the IPAddresses will be assigned a new values "simulating a real life scan".
         * it will print 2 massages. one for the beginning of the scan and one for the end of it.
         */
        public void preformScan() {
            if (IPAddresses == null){           //if the list is empty
                IPAddresses = setIPAddress();   //fill it with random IPs
            }
            System.out.println("Scanning for new host...");
            System.out.println("New host was found: " + ip);
        }

        /**
         * override to the attack method in the MalwareUnitTemplate abstract class to preforms the action of this current class
         */
        @Override
        public void attack() {
            preformScan();
        }
    }

    /**
     * the class is used to simulate sending a spam email to the IP address that we scanned.
     * it will print a message simulating sending the spam and when the virus is downloaded.
     */
    static class SendingEmail extends MalwareUnitTemplate{
        private final String ip;                //ip address

        /**
         * SendingEmail constructor that takes ip as a parameter
         * @param ip the IP that is being scanned
         */
        public SendingEmail(String ip) {
            this.ip = ip;
        }

        /**
         * the function simulate sending an email to the target IP and infecting it with the virus.
         */
        public void preformSendingEmail(){
            System.out.println("Sending an email to the user...");
            System.out.println("Virus downloaded successfully in host: " + ip);
        }

        /**
         * override to the attack method in the MalwareUnitTemplate abstract class to preforms the action of this current class
         */
        @Override
        public void attack() {
            preformSendingEmail();
        }
    }

    /**
     * the class simulate establishing the connection from the attacker to the target machine
     */
    static class EstablishConnection extends MalwareUnitTemplate{
        private final String ip;                //ip address

        /**
         * EstablishConnection constructor that takes ip as a parameter
         * @param ip the IP that is being scanned
         */
        public EstablishConnection(String ip) {
            this.ip = ip;
        }

        /**
         * the class simulate the process of establishing the connection between the victim and the attacker.
         */
        public void preformEstablishConnection() {
            System.out.println("Establishing a connection to the attacker...");
            System.out.println("Connection is established from " + ip + " to attacker");
        }

        /**
         * override to the attack method in the MalwareUnitTemplate abstract class to preforms the action of this current class
         */
        @Override
        public void attack() {
            preformEstablishConnection();
        }
    }

    /**
     * the class simulate dumping the SAM file of the victim's machine
     */
    static class DumpSAMFile extends MalwareUnitTemplate{

        /**
         * DumpSamFile constructor takes no parameters
         */
        public DumpSAMFile (){}

        /**
         * the method simulate the process of dumping the SAM file.
         */
        public void preformDumpSAMFile() {
            System.out.println("Dumping the SAM file...");
            System.out.println("SAM file dumped successfully");
        }

        /**
         * override to the attack method in the MalwareUnitTemplate abstract class to preforms the action of this current class
         */
        @Override
        public void attack() {
            preformDumpSAMFile();
        }
    }

    /**
     * the class simulate cracking the password of the victim's machine
     */
    static class CrackPassword extends MalwareUnitTemplate{
        private final String ip;                //ip address
        private final String passwordValue;     //password that was assigned to the ip that is used in this instance

        /**
         * CrackPassword constructor that takes ip and passwordValue as parameters
         * @param ip the IP that is being scanned
         * @param passwordValue the password that was assigned to the IP address
         */
        public CrackPassword(String ip, String passwordValue) {
            this.ip = ip;
            this.passwordValue = passwordValue;
        }

        /**
         * the method simulate the process of cracking the password.
         */
        public void preformCrackPassword() {
            System.out.println("Cracking the password...");
            System.out.println("The password for host " + ip + " is: " + passwordValue);
        }

        /**
         * override to the attack method in the MalwareUnitTemplate abstract class to preforms the action of this current class
         */
        @Override
        public void attack() {
            preformCrackPassword();
        }
    }

    /**
     * the class simulate the post exploitation process where it would delete logs from the victim's machine
     */
    static class DeleteLogs extends MalwareUnitTemplate{
        private final String ip;                //ip address

        /**
         * DeleteLogs constructor that takes ip as a parameter
         * @param ip the IP that is being scanned
         */
        public DeleteLogs(String ip) {
            this.ip = ip;
        }

        /**
         * this method simulating the deleting of the logs on the victim's machine after cracking the password.
         */
        public void preformDeleteLogs() {
            System.out.println("Deleting Logs from host: " + ip);
            System.out.println("Logs are deleted successfully");
        }

        /**
         * override to the attack method in the MalwareUnitTemplate abstract class to preforms the action of this current class
         */
        @Override
        public void attack() {
            preformDeleteLogs();
        }
    }

    /**
     * class that implements the DatabaseDisplayStrategy interface that takes IP addresses' List and passwords' List as parameters
     * and displays them.
     */
    public static class SimpleDisplayStrategy implements DatabaseDisplayStrategy {
        /**
         * method that takes the Lists "IPAddresses and passwords" and display them
         * @param ipAddresses the list of the IPs that were found or given
         * @param passwords the passwords that are found with the IPs
         */
        public void display(List<String> ipAddresses, Map<String, String> passwords) {
            System.out.println("Database collection:");
            if (ipAddresses != null) {                                                              //if the list of ip addresses is not empty
                ipAddresses.forEach(ip -> {                                                         //for every IP
                    System.out.println("The password for " + ip + " is " + passwords.get(ip));      //print the ip and its password
                });
            } else {
                System.out.println("The Database is empty");
            }
        }
    }

    /**
     * this class serves as a logger to the actions of the virus unit
     */
    public static class LoggingObserver implements MalwareActionObserver {
        /**
         * the method override the update method and display a logging message of the action of the current active unit
         * @param malwareUnit the current active virus
         * @param action the action that the virus preforms
         */
        @Override
        public void update(MalwareUnit malwareUnit, String action) {
            System.out.println("Logging Action: " + action + " for unit " + malwareUnit.getName());
        }
    }

    /**
     * this class serves as a monitor for the viruses actions
     */
    public static class MonitoringObserver implements MalwareActionObserver {
        /**
         * this method is override to the update method for the observer interface, and it serves as a monitor to the actions of the current active unit
         * @param malwareUnit the current active virus
         * @param action the action that this virus do
         */
        @Override
        public void update(MalwareUnit malwareUnit, String action) {
            System.out.println("Monitoring Action: " + action + " for unit " + malwareUnit.getName());
        }
    }
}
